var documenterSearchIndex = {"docs":
[{"location":"divisors.html#Divisors","page":"Divisors","title":"Divisors","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"A divisor D on a Mori dream space X is modeled by the integral vector a=(a_1 dots a_r) such that D = a_1 D^1_X +  + a_r D^r_X, where D^i_X are the restrictions of the torus invariant prime divisors of the canonical toric ambient variety. For divisors on mathbbC^*-surfaces, double index notation can be used for the coefficients.","category":"page"},{"location":"divisors.html#Types","page":"Divisors","title":"Types","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"MoriDreamSpaceDivisor\nCStarSurfaceDivisor\nToricSurfaceDivisor\nSurfaceWithTorusActionDivisor","category":"page"},{"location":"divisors.html#CStarSurfaces.MoriDreamSpaceDivisor","page":"Divisors","title":"CStarSurfaces.MoriDreamSpaceDivisor","text":"MoriDreamSpaceDivisor{T <: MoriDreamSpace}\n\nA Weil divisor on a Mori Dream Space of type T.\n\n\n\n\n\n","category":"type"},{"location":"divisors.html#CStarSurfaces.CStarSurfaceDivisor","page":"Divisors","title":"CStarSurfaces.CStarSurfaceDivisor","text":"CStarSurfaceDivisor{T} = MoriDreamSpaceDivisor{CStarSurface{T}}\n\nA Weil divisor on a mathbbC^*-surface of type T <: CStarSurfaceCase.\n\n\n\n\n\n","category":"type"},{"location":"divisors.html#CStarSurfaces.ToricSurfaceDivisor","page":"Divisors","title":"CStarSurfaces.ToricSurfaceDivisor","text":"ToricSurfaceDivisor = MoriDreamSpaceDivisor{ToricSurface}\n\nA Weil divisor on a toric surface.\n\n\n\n\n\n","category":"type"},{"location":"divisors.html#CStarSurfaces.SurfaceWithTorusActionDivisor","page":"Divisors","title":"CStarSurfaces.SurfaceWithTorusActionDivisor","text":"SurfaceWithTorusActionDivisor = Union{CStarSurfaceDivisor, ToricSurfaceDivisor}\n\nA Weil divisor on a surface with non-trivial torus action.\n\n\n\n\n\n","category":"type"},{"location":"divisors.html#Constuctors","page":"Divisors","title":"Constuctors","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"mori_dream_space_divisor(X :: T, coeffs :: Vector{S}) where {T <: MoriDreamSpace, S <: IntegerUnion}\nmori_dream_space_divisor(X :: T, td :: ToricDivisor) where {T <: MoriDreamSpace}\ncstar_surface_divisor(X :: CStarSurface{EE}, coeffs :: DoubleVector{<:IntegerUnion})\ncstar_surface_divisor(X :: CStarSurface{PE}, coeffs :: DoubleVector{T}, coeff_plus :: T) where {T <: IntegerUnion}\ncstar_surface_divisor(X :: CStarSurface{EP}, coeffs :: DoubleVector{T}, coeff_minus :: T) where {T <: IntegerUnion}\ncstar_surface_divisor(X :: CStarSurface{PP}, coeffs :: DoubleVector{T}, coeff_plus :: T, coeff_minus :: T) where {T <: IntegerUnion}\ninvariant_divisor(X :: CStarSurface, i :: Int, j :: Int)\nD_plus\nD_minus\ntoric_surface_divisor(X :: ToricSurface, coeffs :: Vector{S}) where {S <: IntegerUnion}\ninvariant_divisor(X :: ToricSurface, i :: Int)","category":"page"},{"location":"divisors.html#CStarSurfaces.mori_dream_space_divisor-Union{Tuple{S}, Tuple{T}, Tuple{T, Vector{S}}} where {T<:MoriDreamSpace, S<:Union{Integer, ZZRingElem}}","page":"Divisors","title":"CStarSurfaces.mori_dream_space_divisor","text":"mori_dream_space_divisor(X :: T, coeffs :: Vector{S})\n\nConstruct a divisor on a Mori Dream Space as a linear combination of the (restrictions of) the torus invariant prime divisors of the canonical  toric ambient variety.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[2, 1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> D = cstar_surface_divisor(X, [0, 1, -1, 3])\nCStarSurfaceDivisor{EE}(C-star surface of type (e-e), [0, 1, -1, 3], #undef)\n\njulia> coefficients(D)\n4-element Vector{Int64}:\n  0\n  1\n -1\n  3\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.mori_dream_space_divisor-Union{Tuple{T}, Tuple{T, ToricDivisor}} where T<:MoriDreamSpace","page":"Divisors","title":"CStarSurfaces.mori_dream_space_divisor","text":"mori_dream_space_divisor(X :: T, d :: ToricDivisor)\n\nReturn the Divisor on a Mori Dream Space associated to a toric divisor on its canonical toric ambient space.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.cstar_surface_divisor-Tuple{CStarSurface{EE}, OffsetArrays.OffsetArray{Vector{var\"#s6\"}, 1, S} where {var\"#s6\"<:Union{Integer, ZZRingElem}, S}}","page":"Divisors","title":"CStarSurfaces.cstar_surface_divisor","text":"cstar_surface_divisor(X :: CStarSurface{EE}, coeffs :: DoubleVector{<:IntegerUnion})\n\nConstruct a divisor on a mathbbC^*-surface of type (e-e) as a linear combination of the invariant prime divisors D^ij_X. The coefficients are given in double index notation.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.cstar_surface_divisor-Union{Tuple{T}, Tuple{CStarSurface{PE}, OffsetArrays.OffsetArray{Vector{T}, 1, S} where S, T}} where T<:Union{Integer, ZZRingElem}","page":"Divisors","title":"CStarSurfaces.cstar_surface_divisor","text":"cstar_surface_divisor(X :: CStarSurface{PE}, coeffs :: DoubleVector{T}, coeff_plus :: T) where {T <: IntegerUnion}\n\nConstruct a divisor on a mathbbC^*-surface of type (p-e) as a linear combination of the invariant prime divisors D^ij_X and D^+_X. The coefficients are given in double index notation.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.cstar_surface_divisor-Union{Tuple{T}, Tuple{CStarSurface{EP}, OffsetArrays.OffsetArray{Vector{T}, 1, S} where S, T}} where T<:Union{Integer, ZZRingElem}","page":"Divisors","title":"CStarSurfaces.cstar_surface_divisor","text":"cstar_surface_divisor(X :: CStarSurface{EP}, coeffs :: DoubleVector{T}, coeff_minus :: T) where {T <: IntegerUnion}\n\nConstruct a divisor on a mathbbC^*-surface of type (e-p) as a linear combination of the invariant prime divisors D^ij_X and D^-_X. The coefficients are given in double index notation.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.cstar_surface_divisor-Union{Tuple{T}, Tuple{CStarSurface{PP}, OffsetArrays.OffsetArray{Vector{T}, 1, S} where S, T, T}} where T<:Union{Integer, ZZRingElem}","page":"Divisors","title":"CStarSurfaces.cstar_surface_divisor","text":"cstar_surface_divisor(X :: CStarSurface{PP}, coeffs :: DoubleVector{T}, coeff_plus :: T, coeff_minus :: T) where {T <: IntegerUnion}\n\nConstruct a divisor on a mathbbC^*-surface of type (p-p) as a linear combination of the invariant prime divisors D^ij_X and D^+_X D^-_X. The coefficients are given in double index notation.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.invariant_divisor-Tuple{CStarSurface, Int64, Int64}","page":"Divisors","title":"CStarSurfaces.invariant_divisor","text":"invariant_divisor(X :: CStarSurface, i :: Int, j :: Int)\n\nReturn the (ij)-th invariant divisor D^ij_X.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.D_plus","page":"Divisors","title":"CStarSurfaces.D_plus","text":"D_plus(X :: CStarSurface{<:Union{PE,PP}})\n\nReturn the parabolic fixed point curve D^+ of a mathbbC^*-surface of type (p-e) or (p-p).\n\n\n\n\n\n","category":"function"},{"location":"divisors.html#CStarSurfaces.D_minus","page":"Divisors","title":"CStarSurfaces.D_minus","text":"D_minus(X :: CStarSurface{<:Union{EP,PP}})\n\nReturn the parabolic fixed point curve D^- of a mathbbC^*-surface of type (e-p) or (p-p).\n\n\n\n\n\n","category":"function"},{"location":"divisors.html#CStarSurfaces.toric_surface_divisor-Union{Tuple{S}, Tuple{ToricSurface, Vector{S}}} where S<:Union{Integer, ZZRingElem}","page":"Divisors","title":"CStarSurfaces.toric_surface_divisor","text":"toric_surface_divisor(X :: ToricSurface, coeffs :: Vector{S}) where {S <: IntegerUnion}\n\nConstruct a divisor on a toric surface as a linear combination of the the torus invariant prime divisors.\n\nExample\n\njulia> X = toric_surface([[1,0], [0,1], [-1,-5], [0,-1]])\nNormal toric surface\n\njulia> D = toric_surface_divisor(X, [1, 2, -1, 5])\nToricSurfaceDivisor(Normal toric surface, [1, 2, -1, 5], #undef)\n\njulia> coefficients(D)\n4-element Vector{Int64}:\n  1\n  2\n -1\n  5\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.invariant_divisor-Tuple{ToricSurface, Int64}","page":"Divisors","title":"CStarSurfaces.invariant_divisor","text":"invariant_divisor(X :: ToricSurface, i :: Int)\n\nReturn the i-th toric divisor D^i_X.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#(Anti)canonical-divisor","page":"Divisors","title":"(Anti)canonical divisor","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"canonical_divisor(X :: MoriDreamSpace)\nanticanonical_divisor(X :: MoriDreamSpace)\ncanonical_divisor_class(X :: MoriDreamSpace)\nanticanonical_divisor_class(X :: MoriDreamSpace)","category":"page"},{"location":"divisors.html#Hecke.canonical_divisor-Tuple{MoriDreamSpace}","page":"Divisors","title":"Hecke.canonical_divisor","text":"canonical_divisor(X :: MoriDreamSpace)\n\nReturn the canonical divisor of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> coefficients(canonical_divisor(X))\n4-element Vector{Int64}:\n  0\n  0\n -1\n -1\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Oscar.anticanonical_divisor-Tuple{MoriDreamSpace}","page":"Divisors","title":"Oscar.anticanonical_divisor","text":"anticanonical_divisor(X :: MoriDreamSpace)\n\nReturn the anticanonical divisor of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> coefficients(anticanonical_divisor(X))\n4-element Vector{Int64}:\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Oscar.canonical_divisor_class-Tuple{MoriDreamSpace}","page":"Divisors","title":"Oscar.canonical_divisor_class","text":"canonical_divisor_class(X :: MoriDreamSpace)\n\nReturn the canonical divisor class of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> divisor_class(canonical_divisor_class(X))\nElement of\nGrpAb: Z/4 x Z\nwith components [0 -2]\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Oscar.anticanonical_divisor_class-Tuple{MoriDreamSpace}","page":"Divisors","title":"Oscar.anticanonical_divisor_class","text":"anticanonical_divisor_class(X :: MoriDreamSpace)\n\nReturn the anticanonical divisor class of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> divisor_class(anticanonical_divisor_class(X))\nElement of\nGrpAb: Z/4 x Z\nwith components [0 2]\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Attributes","page":"Divisors","title":"Attributes","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"coefficients(d :: MoriDreamSpaceDivisor)\ntoric_divisor(d :: MoriDreamSpaceDivisor)\ndouble_coefficients(d :: CStarSurfaceDivisor)\nis_prime(d :: MoriDreamSpaceDivisor{T}) where {T <: MoriDreamSpace}","category":"page"},{"location":"divisors.html#Oscar.coefficients-Tuple{MoriDreamSpaceDivisor}","page":"Divisors","title":"Oscar.coefficients","text":"coefficients(d :: MoriDreamSpaceDivisor)\n\nReturn the coefficients of a divisor on a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Oscar.toric_divisor-Tuple{MoriDreamSpaceDivisor}","page":"Divisors","title":"Oscar.toric_divisor","text":"toric_divisor(d :: MoriDreamSpaceDivisor)\n\nReturn the toric divisor on the canonical toric ambient variety associated  to a divisor on a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#CStarSurfaces.double_coefficients-Tuple{CStarSurfaceDivisor{T} where T}","page":"Divisors","title":"CStarSurfaces.double_coefficients","text":"double_coefficients(d :: CStarSurfaceDivisor)\n\nReturn the coefficients of a divisor on a mathbbC^*-surface, in double index notation.\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Nemo.is_prime-Union{Tuple{MoriDreamSpaceDivisor{T}}, Tuple{T}} where T<:MoriDreamSpace","page":"Divisors","title":"Nemo.is_prime","text":"is_prime(d :: MoriDreamSpaceDivisor{T}) where {T <: MoriDreamSpace}\n\nCheck whether a given divisor is a prime divisor.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_prime(invariant_divisor(X, 0, 1))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Intersection-numbers","page":"Divisors","title":"Intersection numbers","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"Base.:*(d1 :: SurfaceWithTorusActionDivisor, d2 :: SurfaceWithTorusActionDivisor)","category":"page"},{"location":"divisors.html#Base.:*-Tuple{SurfaceWithTorusActionDivisor, SurfaceWithTorusActionDivisor}","page":"Divisors","title":"Base.:*","text":"Base.:*(d1 :: SurfaceWithTorusActionDivisor, d2 :: SurfaceWithTorusActionDivisor)\n\nReturn the intersection number of two divisors on a surface with torus action. The divisors have to be defined on the same variety.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> D = cstar_surface_divisor(X, [1, 0, 2, -1])\nCStarSurfaceDivisor{EE}(C-star surface of type (e-e), [1, 0, 2, -1], #undef)\n\njulia> D * D\n4//3\n\n\n\n\n\n","category":"method"},{"location":"divisors.html#Contraction","page":"Divisors","title":"Contraction","text":"","category":"section"},{"location":"divisors.html","page":"Divisors","title":"Divisors","text":"contract_prime_divisor(d :: CStarSurfaceDivisor{T}) where {T <: CStarSurfaceCase}","category":"page"},{"location":"divisors.html#CStarSurfaces.contract_prime_divisor-Union{Tuple{CStarSurfaceDivisor{T}}, Tuple{T}} where T<:CStarSurfaceCase","page":"Divisors","title":"CStarSurfaces.contract_prime_divisor","text":"contract_prime_divisor(d :: CStarSurfaceDivisor{T}) where {T <: CStarSurfaceCase}\n\nContract the given prime divisor and return the resulting mathbbC^*-surface. This amounts to deleting the associated ray from the generator matrix.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ep)\nC-star surface of type (e-p)\n\njulia> contract_prime_divisor(D_minus(X))\nC-star surface of type (e-e)\n\n\n\n\n\n","category":"method"},{"location":"database_functionality.html#Database-functionality","page":"Database functionality","title":"Database functionality","text":"","category":"section"},{"location":"database_functionality.html","page":"Database functionality","title":"Database functionality","text":"CStarSurfaces.jl has the ability to interact with database connections for saving and retrieving Mori dream spaces and their properties. The interface here is generic, but currently only an SQLite database holding SurfaceWithTorusAction's is supported.","category":"page"},{"location":"database_functionality.html","page":"Database functionality","title":"Database functionality","text":"A connection to the online ldp-database is planned.","category":"page"},{"location":"database_functionality.html","page":"Database functionality","title":"Database functionality","text":"DatabaseAdapter\nSQLiteAdapter\nSQLiteAdapterSurfaces\ncreate_table\nimport_from_database\nfind_in_database\ndefault_column_functions\ndefault_insert_predicate\nsqlite_import_row\nexport_to_database\nupdate_in_database\nexecute_on_database","category":"page"},{"location":"database_functionality.html#CStarSurfaces.DatabaseAdapter","page":"Database functionality","title":"CStarSurfaces.DatabaseAdapter","text":"DatabaseAdapter{T <: MoriDreamSpace}\n\nAbstract type of a database adapter holding objects of a common subtype of MoriDreamSpace. Subtypes of DatabaseAdapter{T} should at least implement the following functions:\n\nimport_from_database, find_in_database.\n\nIf the database is writeable, the following functions should be implemented as well:\n\nexport_to_database, update_in_database.\n\n\n\n\n\n","category":"type"},{"location":"database_functionality.html#CStarSurfaces.SQLiteAdapter","page":"Database functionality","title":"CStarSurfaces.SQLiteAdapter","text":"SQLiteAdapter{T} <: DatabaseAdapter{T}\n\nAn adapter to an SQLite database holding objects of type T where T <: MoriDreamSpace. The type T should at least implement the following methods: create_table, default_column_functions, find_in_database, sqlite_import_row.\n\n\n\n\n\n","category":"type"},{"location":"database_functionality.html#CStarSurfaces.SQLiteAdapterSurfaces","page":"Database functionality","title":"CStarSurfaces.SQLiteAdapterSurfaces","text":"SQLiteAdapterSurfaces = SQLiteAdapter{SurfaceWithTorusAction}\n\nAn adapter to an SQLite database holding objects of type SurfaceWithTorusAction.\n\n\n\n\n\n","category":"type"},{"location":"database_functionality.html#CStarSurfaces.create_table","page":"Database functionality","title":"CStarSurfaces.create_table","text":"create_table(db :: SQLiteAdapterSurfaces; temp = false, ifnotexists = true)\n\nCreate a new SQLite table with default column definitions holding SurfaceWithTorusActions.\n\nExample\n\nCreate a new SQLite database for holding SurfaceWithTorusActions. The resulting table can be inspected with SQLite.jl:\n\njulia> db = SQLiteAdapterSurfaces(\"my_database.db\", \"surfaces\", \"surface_id\")\nSQLiteAdapterSurfaces(SQLite.DB(\"my_database.db\"), \"my_database.db\", \"surfaces\", \"surface_id\")\n\njulia> create_table(db);\n\njulia> using SQLite\n\njulia> SQLite.tables(db.db)\n1-element Vector{SQLite.DBTable}:\n SQLite.DBTable(\"surfaces\", Tables.Schema:\n :surface_id                                   Union{Missing, Int64}\n :is_toric                                     Union{Missing, Int64}\n :gen_matrix                                   Union{Missing, String}\n :rays                                         Union{Missing, String}\n :nrays                                        Union{Missing, Int64}\n :lss                                          Union{Missing, String}\n :dss                                          Union{Missing, String}\n :case_                                        Union{Missing, String}\n :block_sizes                                  Union{Missing, String}\n :nblocks                                      Union{Missing, Int64}\n :number_of_parabolic_fixed_point_curves       Union{Missing, Int64}\n :orientation                                  Union{Missing, Int64}\n :is_intrinsic_quadric                         Union{Missing, Int64}\n :class_group_rank                             Union{Missing, Int64}\n :class_group_torsion                          Union{Missing, String}\n :class_group_torsion_order                    Union{Missing, Int64}\n :degree_matrix                                Union{Missing, String}\n :canonical_divisor_class                      Union{Missing, String}\n :gorenstein_index                             Union{Missing, Int64}\n :picard_index                                 Union{Missing, Int64}\n :log_canonicity_numerator                     Union{Missing, Int64}\n :log_canonicity_denominator                   Union{Missing, Int64}\n :log_canonicity                               Union{Missing, Float64}\n :anticanonical_self_intersection_numerator    Union{Missing, Int64}\n :anticanonical_self_intersection_denominator  Union{Missing, Int64}\n :anticanonical_self_intersection              Union{Missing, Float64}\n :admits_kaehler_ricci_soliton                 Union{Missing, Int64}\n :admits_kaehler_einstein_metric               Union{Missing, Int64}\n :admits_sasaki_einstein_metric                Union{Missing, Int64}\n :is_quasismooth                               Union{Missing, Int64}\n :is_factorial                                 Union{Missing, Int64}\n :is_smooth                                    Union{Missing, Int64}\n :number_of_singularities                      Union{Missing, Int64})\n\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.import_from_database","page":"Database functionality","title":"CStarSurfaces.import_from_database","text":"import_from_database(db :: SQLiteAdapter{T}, sql :: String = \"TRUE\") where {T <: MoriDreamSpace}\n\nReturn a list of objects of type T that match a given sql query. The string sql is used after the WHERE in a SELECT statement, hence can contain restrictions on the columns as well as an ORDER BY and a LIMIT clause.\n\n\n\n\n\nimport_from_database(db :: SQLiteAdapter{T}, ids :: AbstractVector{Int}) where {T <: MoriDreamSpace}\n\nReturn the list of objects of type T from an SQLite database with the given ids.\n\n\n\n\n\nimport_from_database(db :: SQLiteAdapter{T}, id :: Int) where {T <: MoriDreamSpace}\n\nReturn the object of type T from an SQLite database with the given id.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.find_in_database","page":"Database functionality","title":"CStarSurfaces.find_in_database","text":"find_in_database(db :: SQLiteAdapterSurfaces, X :: SurfaceWithTorusAction)\n\nTries to find a SurfaceWithTorusAction in an SQLite database. If the surface is in the database, this function returns its id. Otherwise, it returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.default_column_functions","page":"Database functionality","title":"CStarSurfaces.default_column_functions","text":"default_column_functions(::Type{T}) where {T <: MoriDreamSpace}\n\nReturns a Dict{Symbol, Function} that serves as a default for the names of the columns to export and how to export them for a given subtype of MoriDreamSpace. This should be implemented by all subtypes of MoriDreamSpace where database functionality is desired.\n\nThe fallback definition for a general T returns an empty dictionary.\n\n\n\n\n\ndefault_column_functions(::Type{<:SurfaceWithTorusAction})\n\nThe default columns names and how to compute them when exporting objects of type SurfaceWithTorusAction to an SQLite database. \n\nThe function names all have the prefix _db_ followed by the name of the column, for instance CStarSurfaces._db_gen_matrix (they are not exported by default). They basically wrap the corresponding attribute function, giving the result as a language-agnostic string for database storage instead of a Julia type.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.default_insert_predicate","page":"Database functionality","title":"CStarSurfaces.default_insert_predicate","text":"default_insert_predicate(::Type{T}) where {T <: MoriDreamSpace}\n\nReturns a function of type (db :: SQLiteAdapter{T}, X :: T) -> Bool that serves as the default insert predicate when exporting objects of type T to an SQLite database. The default implementation returns true if and only if find_in_database(db, X) returns nothing, hence avoiding duplicate entries in the database. Note that there is no default implementation for find_in_database, it has to be implemented for each subtype of MoriDreamSpace where database functionality is desired.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.sqlite_import_row","page":"Database functionality","title":"CStarSurfaces.sqlite_import_row","text":"sqlite_import_row(::Type{SurfaceWithTorusAction}, row :: Union{SQLite.Row, NamedTuple})\n\nImports a single row from an SQLiteAdapterSurfaces into a SurfaceWithTorusAction.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.export_to_database","page":"Database functionality","title":"CStarSurfaces.export_to_database","text":"export_to_database(db_adapter :: SQLiteAdapter{T}, Xs :: AbstractVector; kwargs...) where {T <: MoriDreamSpace}\n\nExport a list Xs of varieties of type T to an SQLite database. The following keyword arguments are supported:\n\ncolumn_functions: Defaults to default_column_functions(T). A dictionary of type Dict{Symbol, Function} containing for each exported column name a function that tells export_to_database how to compute that column. Each function takes an object of type T and returns an SQLite compatible data type (Int, Float, String or Nothing).\ninsert_predicate: Defaults to default_insert_predicate(T). A function of  type (db :: SQLiteAdapter{T}, X :: T) -> Bool. Only objects where this predicate evaluates to true are exported.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.update_in_database","page":"Database functionality","title":"CStarSurfaces.update_in_database","text":"update_in_database(db :: SQLiteAdapter{T}, column_functions :: Dict{Symbol, <:Function}; sql :: String, column_function_args :: AbstractVector{Symbol}) where {T <: MoriDreamSpace}\n\nUpdate all rows in an SQLite database matching a given SQL query by recomputing the columns given by column_functions. See also export_to_database and import_from_database.\n\nKeyword arguments:\n\nsql :: String, defaults to \"TRUE\". The SQL expression used for filtering the  rows in the database that should be updated. It is inserted into a SELECT statement after the WHERE, hence can contain restrictions on the columns as well as  an ORDER BY and a LIMIT clause.\ncolumn_function_args :: AbstractVector{String}, defaults to [:variety]. The  list of arguments that each column function receives. These can either be names of columns in the database, or the special symbol :variety, in which case the  variety corresponding to the row is imported using sqlite_import_row and then  passed as an argument.\n\n\n\n\n\nupdate_in_database(db :: SQLiteAdapter{T}, ids :: AbstractVector{Int}, column_functions :: Dict{Symbol, <:Function}; column_function_args :: AbstractVector{Symbol}) where {T <: MoriDreamSpace})\n\nUpdate all rows in an SQLite database with the given ids by recomputing the columns given by column_functions.\n\n\n\n\n\nupdate_in_database(db :: SQLiteAdapter{T}, id :: Int, column_functions :: Dict{Symbol, <:Function}, column_function_args :: AbstractVector{Symbol}) where {T <: MoriDreamSpace}))\n\nUpdate all rows in an SQLite database with the given id by recomputing the columns given by column_functions.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.execute_on_database","page":"Database functionality","title":"CStarSurfaces.execute_on_database","text":"execute_on_database(f :: Function, db :: SQLiteAdapter{T}; sql :: String = \"TRUE\", function_args :: AbstractVector{Symbol} = [:variety]) where {T <: MoriDreamSpace}\n\nExecutes f on all rows of an SQLite database that are filtered sql. The argument function_args can be used to control the arguments that will be passed to f. See also update_in_database.\n\n\n\n\n\n","category":"function"},{"location":"docs_index.html","page":"Index","title":"Index","text":"","category":"page"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"CurrentModule = CStarSurfaces","category":"page"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"using CStarSurfaces, Oscar ","category":"page"},{"location":"surfaces_with_torus_action.html#Surfaces-with-torus-action","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"The two main Julia types in this packages are CStarSurface and ToricSurface. Some functionality also works for MoriDreamSpace's, an abstract type of which CStarSurface and ToricSurface are subtypes.","category":"page"},{"location":"surfaces_with_torus_action.html#Julia-types","page":"Surfaces with torus action","title":"Julia types","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"MoriDreamSpace\nCStarSurfaceCase\nCStarSurface\nToricSurface\nSurfaceWithTorusAction\nMoriDreamSpaceUnion","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.MoriDreamSpace","page":"Surfaces with torus action","title":"CStarSurfaces.MoriDreamSpace","text":"MoriDreamSpace\n\nJulia type for Mori Dream Spaces.\n\nSubtypes of MoriDreamSpace should at least implement the following methods: canonical_toric_ambient, cox_ring_relations, is_quasismooth.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.CStarSurfaceCase","page":"Surfaces with torus action","title":"CStarSurfaces.CStarSurfaceCase","text":"CStarSurfaceCase\n\nThe abstract supertype of the possible possible configurations of source and sink of a mathbbC^*-surface.\n\nThis type has the four subtypes EE, EP, PE and PP, named after the existence of elliptic fixed points and parabolic fixed point curves in the source and sink of a mathbbC^*-surface respectively.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.CStarSurface","page":"Surfaces with torus action","title":"CStarSurfaces.CStarSurface","text":"CStarSurface{T<:CStarSurfaceCase} <: MoriDreamSpace\n\nA mathbbC^*-surface of case T <: CStarSurfaceCase. As a Julia type, it gets modeled by a stuct with fields l, d and case, where l and d are zero-indexed vectors of one-indexed vectors of integers and case is one of the four symbols :ee, :pe, :ep and :pp.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.ToricSurface","page":"Surfaces with torus action","title":"CStarSurfaces.ToricSurface","text":"ToricSurface <: MoriDreamSpace\n\nA toric surface. As a Julia type, it gets modeled by a struct with a single field vs that stores the primitive generator of the rays of the two-dimensional complete fan describing the toric surface.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.SurfaceWithTorusAction","page":"Surfaces with torus action","title":"CStarSurfaces.SurfaceWithTorusAction","text":"SurfaceWithTorusAction = Union{CStarSurface, ToricSurface}\n\nThe Union of CStarSurface and ToricSurface.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.MoriDreamSpaceUnion","page":"Surfaces with torus action","title":"CStarSurfaces.MoriDreamSpaceUnion","text":"MoriDreamSpaceUnion\n\nThe Union of MoriDreamSpace and Oscar's NormalToricVarietyType.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#Constructors","page":"Surfaces with torus action","title":"Constructors","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"cstar_surface(ls :: Vector{Vector{Int64}}, ds :: Vector{Vector{Int64}}, case :: Symbol)\ncstar_surface(P :: ZZMatrix)\ntoric_surface(vs :: Vector{Vector{T}}) where {T <: IntegerUnion}\ntoric_surface(P :: ZZMatrix)","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cstar_surface-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}, Symbol}","page":"Surfaces with torus action","title":"CStarSurfaces.cstar_surface","text":"cstar_surface(ls :: Vector{Vector{Int64}}, ds :: Vector{Vector{Int64}}, case :: Symbol)\n\nConstruct a C-star surface from the integral vectors l_i=(l_i1  l_in_i) and d_i=(d_i1  d_in_i) and a given C-star surface case. The parameters ls and ds are given both given as a vector of vectors. They must be of the same length and satisfy gcd(ls[i][j], ds[i][j]) == 1 for all i and j. The parameter case can be one of the four symbols :ee, :pe, :ep, :pp.\n\nExample\n\nThe E_6 singular cubic.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\njulia> gen_matrix(X)\n[-3   -1   3   0]\n[-3   -1   0   2]\n[-2   -1   1   1]\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cstar_surface-Tuple{ZZMatrix}","page":"Surfaces with torus action","title":"CStarSurfaces.cstar_surface","text":"cstar_surface(P :: ZZMatrix)\n\nConstruct a C-star surface from a generator matrix of the correct format. That is, P must be of one of the following forms:\n\nbeginarraylcclc\ntext(e-e)  \nbeginbmatrix\nL \nd\nendbmatrix \nqquad \ntext(p-e) \nbeginbmatrix\nL  0 \nd  1\nendbmatrix \n\ntext(e-p) \nbeginbmatrix\nL  0 \nd  -1\nendbmatrix \nqquad \ntext(p-p) \nbeginbmatrix\nL  0  0 \nd  1  -1\nendbmatrix\nendarray\n\nwhere for some integral vectors l_i=(l_i1  l_in_i) in mathbbZ^n_i_geq 0 and d_i=(d_i1  d_in_i) in mathbbZ^n_i with gcd(l_ij d_ij) = 1, we have\n\nL = beginbmatrix\n-l_0  l_1  dots  0 \nvdots   ddots  0 \n-l_0  0  dots  l_r\nendbmatrix \nqquad\nd = beginbmatrix\nd_0  dots  d_r\nendbmatrix\n\nExample\n\nThe E_6 singular cubic.\n\njulia> cstar_surface(ZZ[-3 -1 3 0 ; -3 -1 0 2 ; -2 -1 1 1])\nC-star surface of type (e-e)\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.toric_surface-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Union{Integer, ZZRingElem}","page":"Surfaces with torus action","title":"CStarSurfaces.toric_surface","text":"toric_surface(vs :: Vector{Vector{T}}) where {T <: IntegerUnion}\n\nConstruct a toric surface from a list of integral vectors in two-dimensional space.\n\nExample\n\nThe 5-th Hirzebruch surface.\n\njulia> toric_surface([[1,0], [0,1], [-1,-5], [0,-1]])\nNormal toric surface\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.toric_surface-Tuple{ZZMatrix}","page":"Surfaces with torus action","title":"CStarSurfaces.toric_surface","text":"toric_surface(P :: ZZMatrix)\n\nConstruct a toric surface from an integral matrix, where the columns of the matrix are the rays of the describing fan.\n\nExample\n\nThe 5-th Hirzebruch surface.\n\njulia> toric_surface(ZZ[1 0 -1 0 ; 0 1 -17 -1])\nNormal toric surface\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Basic-attributes","page":"Surfaces with torus action","title":"Basic attributes","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"gen_matrix(X :: MoriDreamSpaceUnion)\ncanonical_toric_ambient\ncox_ring_relations\ncox_ring(X :: MoriDreamSpace)","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.gen_matrix-Tuple{MoriDreamSpaceUnion}","page":"Surfaces with torus action","title":"CStarSurfaces.gen_matrix","text":"gen_matrix(X :: MoriDreamSpaceUnion)\n\nReturn the generator matrix of a Mori Dream Space X. The columns of this matrix are the rays of the fan of the canonical toric ambient variety of X.\n\nExample\n\njulia> gen_matrix(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n[-3   -1   3   0]\n[-3   -1   0   2]\n[-2   -1   1   1]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.canonical_toric_ambient","page":"Surfaces with torus action","title":"CStarSurfaces.canonical_toric_ambient","text":"canonical_toric_ambient(X :: MoriDreamSpace)\n\nReturn the canonical toric ambient variety of a Mori Dream Space as an OSCAR NormalToricVariety.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> Z = canonical_toric_ambient(X)\nNormal toric variety\n\njulia> rays(Z)\n4-element SubObjectIterator{RayVector{QQFieldElem}}:\n [-1, -1, -2//3]\n [-1, -1, -1]\n [1, 0, 1//3]\n [0, 1, 1//2]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cox_ring_relations","page":"Surfaces with torus action","title":"CStarSurfaces.cox_ring_relations","text":"cox_ring_relations(X :: MoriDreamSpace)\n\nReturn the list of relations in the Cox Ring of a Mori Dream Space. Here, a relation is a RingElem whose parent is the Cox Ring of the canonical toric ambient variety.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Oscar.cox_ring-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.cox_ring","text":"cox_ring(X :: MoriDreamSpace)\n\nReturn the Cox Ring of a Mori Dream Space.\n\nExamples\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> cox_ring(X)\nQuotient\n  of graded multivariate polynomial ring in 4 variables over QQ\n  by ideal(T[0][1]^3*T[0][2] + T[1][1]^3 + T[2][1]^2)\n\njulia> X = toric_surface([[1,0], [1,5], [-2,-5]])\nNormal toric surface\n\njulia> cox_ring(X)\nMultivariate polynomial ring in 3 variables over QQ graded by \n  x1 -> [0 1]\n  x2 -> [2 1]\n  x3 -> [1 1]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Class-group-and-Picard-group","page":"Surfaces with torus action","title":"Class group and Picard group","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"class_group(X :: MoriDreamSpace)\nclass_group_rank(X :: MoriDreamSpace)\nclass_group_torsion(X :: MoriDreamSpace)\nclass_group_torsion_order(X :: MoriDreamSpace)\npicard_group(X :: MoriDreamSpace)\ndegree_matrix(X :: MoriDreamSpaceUnion)\ndegree_matrix_free_part(X :: MoriDreamSpaceUnion)\ndegree_matrix_torsion_part(X :: MoriDreamSpaceUnion)\ngorenstein_index(X :: MoriDreamSpace)\npicard_index(X :: MoriDreamSpace)","category":"page"},{"location":"surfaces_with_torus_action.html#Hecke.class_group-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Hecke.class_group","text":"class_group(X :: MoriDreamSpace)\n\nReturn the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group(cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee))\nGrpAb: Z/4 x Z\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.class_group_rank-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.class_group_rank","text":"class_group_rank(X :: MoriDreamSpaceUnion)\n\nReturn the rank of the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group_rank(cstar_surface([[1, 1], [2], [2]], [[-3, -4], [1], [1]], :pe))\n2\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.class_group_torsion-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.class_group_torsion","text":"class_group_torsion(X :: MoriDreamSpaceUnion)\n\nReturn the list of elementary divisors that make up the torsion part of the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group_torsion(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n2-element Vector{ZZRingElem}:\n 2\n 6\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.class_group_torsion_order-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.class_group_torsion_order","text":"class_group_torsion_order(X :: MoriDreamSpaceUnion)\n\nReturn the order of the torsion part of the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group_torsion_order(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n12\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Hecke.picard_group-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Hecke.picard_group","text":"picard_group(X :: MoriDreamSpace)\n\nReturn the Picard group of a Mori Dream Space.\n\nExample\n\njulia> picard_group(cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee))\nGrpAb: Z\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.degree_matrix-Tuple{MoriDreamSpaceUnion}","page":"Surfaces with torus action","title":"CStarSurfaces.degree_matrix","text":"degree_matrix(X :: MoriDreamSpaceUnion)\n\nReturn the degree matrix of a Mori Dream Space (often denoted as Q). The columns of this matrix are the degrees of the generator of the Cox Ring, which are elements of the divisor class group. Note that we write the torsion parts of these elements first (in the upper rows of the  degree matrix), and the free part after that (in the lower rows of the degree matrix).\n\nExample\n\njulia> degree_matrix(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n[0   1   1   0]\n[0   4   1   5]\n[1   3   4   2]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.degree_matrix_free_part-Tuple{MoriDreamSpaceUnion}","page":"Surfaces with torus action","title":"CStarSurfaces.degree_matrix_free_part","text":"degree_matrix_free_part(X :: MoriDreamSpaceUnion)\n\nThe free part of the degree matrix of a Mori Dream Space. By the convention in this package, these are the lower rows of degree_matrix(X).\n\nExample\n\njulia> degree_matrix_free_part(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n[1   3   4   2]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.degree_matrix_torsion_part-Tuple{MoriDreamSpaceUnion}","page":"Surfaces with torus action","title":"CStarSurfaces.degree_matrix_torsion_part","text":"degree_matrix_torsion_part(X :: MoriDreamSpaceUnion)\n\nThe torsion part of the degree matrix of a Mori Dream Space. By the convention in this package, these are the upper rows of degree_matrix(X).\n\nExample\n\njulia> degree_matrix_torsion_part(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n[0   1   1   0]\n[0   4   1   5]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Oscar.gorenstein_index-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.gorenstein_index","text":"gorenstein_index(X :: MoriDreamSpace)\n\nReturn the Gorenstein index of a mathbbQ-Gorenstein Mori Dream Space.\n\nExample\n\njulia> gorenstein_index(cstar_surface([[1, 1], [11], [5]], [[0, -2], [9], [3]], :ee))\n78\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Oscar.picard_index-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.picard_index","text":"picard_index(X :: MoriDreamSpace)\n\nReturn the index of the Picard group in the class group of a Mori Dream Space.\n\nExample\n\njulia> picard_index(cstar_surface([[1, 1], [7], [7]], [[0, -1], [3], [3]], :ee))\n42\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Singularities-and-Resolutions","page":"Surfaces with torus action","title":"Singularities and Resolutions","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"is_quasismooth(X :: MoriDreamSpace)\nis_factorial(X :: MoriDreamSpace)\nis_smooth(X :: MoriDreamSpace)\nis_log_terminal(X :: SurfaceWithTorusAction)\nlog_canonicity(X :: SurfaceWithTorusAction)\nsingularities(X :: SurfaceWithTorusAction)\nnumber_of_singularities(X :: SurfaceWithTorusAction)\nsingularity_types(X :: SurfaceWithTorusAction)\ncanonical_resolution(X :: CStarSurface)\ncanonical_resolution(X :: ToricSurface)\nminimal_resolution(X :: CStarSurface)","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.is_quasismooth-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.is_quasismooth","text":"is_quasismooth(X :: MoriDreamSpace)\n\nChecks whether the Mori Dream Space X is quasismooth, i.e. its characteristic space hat X is smooth.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.is_factorial-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.is_factorial","text":"is_factorial(X :: MoriDreamSpace)\n\nDetermine if a Mori Dream Space has at most factorial singularities, i.e. its canonical toric ambient variety is smooth.\n\nExample\n\njulia> is_factorial(cstar_surface([[1, 1], [7], [7]], [[0, -1], [3], [3]], :ee))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Hecke.is_smooth-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Hecke.is_smooth","text":"is_smooth(X :: MoriDreamSpace)\n\nChecks whether a Mori Dream Space is smooth, i.e. factorial and quasismooth.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.is_log_terminal-Tuple{SurfaceWithTorusAction}","page":"Surfaces with torus action","title":"CStarSurfaces.is_log_terminal","text":"is_log_terminal(X :: SurfaceWithTorusAction)\n\nCheck whether a surface with torus action has at most log terminal singularities.\n\nExample\n\nThe E_6 singular cubic.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_log_terminal(X)\ntrue\n\nA non-log terminal mathbbC^*-surface.\n\njulia> X = cstar_surface([[5, 7], [3], [2]], [[-1, 2], [1], [-1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_log_terminal(X)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.log_canonicity-Tuple{SurfaceWithTorusAction}","page":"Surfaces with torus action","title":"CStarSurfaces.log_canonicity","text":"log_canonicity(X :: SurfaceWithTorusAction)\n\nGiven a surface with torus action X, return the maximal rational number varepsilon such that X is varepsilon-log canonical. By definition, this is the minimal discrepancy in the resolution of singularities plus one.\n\nExample\n\njulia> log_canonicity(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n1//1\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.singularities-Tuple{SurfaceWithTorusAction}","page":"Surfaces with torus action","title":"CStarSurfaces.singularities","text":"singularities(X :: SurfaceWithTorusAction)\n\nReturn the list of singular points of a given surface with torus action.\n\nExample\n\nThe E_6 singular cubic surface.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> singularities(X)\n1-element Vector{CStarSurfaceFixedPoint{EE}}:\n elliptic fixed point x^+\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.number_of_singularities-Tuple{SurfaceWithTorusAction}","page":"Surfaces with torus action","title":"CStarSurfaces.number_of_singularities","text":"number_of_singularities(X :: SurfaceWithTorusAction)\n\nReturn the number of singularities of a given surface with torus action.\n\nExample\n\nThe E_6 singular cubic surface.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> number_of_singularities(X)\n1\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.singularity_types-Tuple{SurfaceWithTorusAction}","page":"Surfaces with torus action","title":"CStarSurfaces.singularity_types","text":"singularity_types(X :: SurfaceWithTorusAction)\n\nReturn the list of singularity types of all singularities of a surface with torus action.\n\nExamples\n\nA mathbbC^*-surface with two Gorenstein singularities.\n\njulia> X = cstar_surface([[1, 2], [3], [3]], [[-1, -3], [2], [2]], :ee)\nC-star surface of type (e-e)\n\njulia> singularity_types(X)\n2-element Vector{SingularityTypeADE}:\n A2\n E6\n\nA non-log terminal mathbbC*-surface.\n\njulia> X = cstar_surface([[5, 7],[3],[2]], [[-1, 2], [1], [-1]], :ee)\nC-star surface of type (e-e)\n\njulia> singularity_types(X)\n3-element Vector{SingularityType}:\n Non log terminal singularity\n E8\n A2\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.canonical_resolution-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.canonical_resolution","text":"canonical_resolution(X :: CStarSurface)\n\nReturn the canonical resolution of singularities of a C-star surface  X. The result is a triple (Y, ex_div, discr) where Y is the smooth C-star surface in the resolution of singularities of X, ex_div contains the exceptional divisors in the resolution and discrepancies contains their discrepancies.\n\nExample\n\nResolution of singularities of the E_6 singular cubic surface.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> (Y, ex_div, discr) = canonical_resolution(X);\n\njulia> gen_matrix(Y)\n[-3   -1   -2   -1   3   2   1   1   0   0   0   0    0]\n[-3   -1   -2   -1   0   0   0   0   2   1   1   0    0]\n[-2   -1   -1    0   1   1   1   0   1   1   0   1   -1]\n\njulia> map(E -> E * E, ex_div)\n9-element Vector{QQFieldElem}:\n -2\n -2\n -2\n -2\n -2\n -2\n -3\n -2\n -1\n\njulia> discr\n9-element Vector{Rational{Int64}}:\n 0//1\n 0//1\n 0//1\n 0//1\n 0//1\n 0//1\n 1//1\n 2//1\n 4//1\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.canonical_resolution-Tuple{ToricSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.canonical_resolution","text":"canonical_resolution(X :: ToricSurface)\n\nReturn the canonical resolution of singularities of a toric surface X. The result is a triple (Y, ex_rays, discrepancies) where Y is the smooth toric surface in the resolution of singularities of X, ex_rays contains the rays of the exceptional divisors in the resolution and discrepancies contains their discrepancies.\n\nExample\n\njulia> X = toric_surface(ZZ[1 1 -3 ; 0 4 -7])\nNormal toric surface\n\njulia> (Y, ex_div, discr) = canonical_resolution(X);\n\njulia> gen_matrix(Y)\n[1   1   -3   1   1   1   0   -1   -2   -1    0]\n[0   4   -7   1   2   3   1   -2   -5   -3   -1]\n\njulia> map(E -> E*E, ex_div)\n8-element Vector{QQFieldElem}:\n -2\n -2\n -2\n -2\n -3\n -2\n -2\n -3\n\njulia> discr\n8-element Vector{Rational{Int64}}:\n  0//1\n  0//1\n  0//1\n -1//5\n -2//5\n -1//7\n -2//7\n -3//7\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.minimal_resolution-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.minimal_resolution","text":"minimal_resolution(X :: CStarSurface)\n\nReturn the minimal resolution of singularities of a C-star surface surface X. The minimal resolution is obtained by contracting all (-1)-curves of the canonical resolution. The result is a triple (Y, ex_div, discr) where Y is the smooth C-star surface in the resolution of singularities of X, ex_div contains the exceptional divisors in the resolution and discrepancies contains their discrepancies.\n\nExample\n\nResolution of singularities of the E_6 singular cubic surface.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> (Y, ex_div, discr) = minimal_resolution(X);\n\njulia> gen_matrix(Y)\n[-3   -1   -2   -1   3   2   1   0   0   0]\n[-3   -1   -2   -1   0   0   0   2   1   0]\n[-2   -1   -1    0   1   1   1   1   1   1]\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Intersection-numbers","page":"Surfaces with torus action","title":"Intersection numbers","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"intersection_matrix\nanticanonical_self_intersection(X :: SurfaceWithTorusAction)","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.intersection_matrix","page":"Surfaces with torus action","title":"CStarSurfaces.intersection_matrix","text":"intersection_matrix(X :: SurfaceWithTorusAction)\n\nReturn the matrix of intersection numbers of all torus invariant prime divisors associated of a surface with torus action with each other. The result is a rational n x n matrix, where n = nrays(X) and the (i,j)-th entry is the intersection number of the prime divisors associated to the i-th and j-th ray respectively.\n\nExamples\n\njulia> intersection_matrix(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n[1//3   1   2//3   1]\n[   1   3      2   3]\n[2//3   2   4//3   2]\n[   1   3      2   3]\n\njulia> intersection_matrix(toric_surface(ZZ[1 0 -1 0 ; 0 1 -17 -1]))\n[0    1   0     1]\n[1   17   1     0]\n[0    1   0     1]\n[1    0   1   -17]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.anticanonical_self_intersection-Tuple{SurfaceWithTorusAction}","page":"Surfaces with torus action","title":"CStarSurfaces.anticanonical_self_intersection","text":"anticanonical_self_intersection(X :: SurfaceWithTorusAction)\n\nReturn the self intersection number of the anticanonical divisor on a surface with torus action.\n\nExample\n\njulia> anticanonical_self_intersection(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n3\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Kaehler-Einstein-metrics","page":"Surfaces with torus action","title":"Kaehler Einstein metrics","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"admits_kaehler_einstein_metric\nspecial_indices(X :: CStarSurface)\nmoment_polytopes(X :: CStarSurface)","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.admits_kaehler_einstein_metric","page":"Surfaces with torus action","title":"CStarSurfaces.admits_kaehler_einstein_metric","text":"admits_kaehler_einstein_metric(X :: SurfaceWithTorusAction)\n\nChecks whether a surface with torus action admits a Kaehler-Einstein metric.\n\nExamples\n\njulia> admits_kaehler_einstein_metric(cstar_surface([[1,1], [4], [4]], [[-1,-2], [3], [3]], :ee))\ntrue\n\njulia> admits_kaehler_einstein_metric(toric_surface([[1,0], [1,5], [-2,-5]]))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.special_indices-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.special_indices","text":"special_indices(X :: CStarSurface)\n\nReturns the subset of indices in 0 : r that are special in the sense of Definition 5.2/Proposition 5.3 of [6], i.e. those where the special fiber of the toric degeneration psi_k  mathcalX_k to mathbbC is a normal toric variety.\n\nExample\n\nExample 6.4 from [6].\n\njulia> X = cstar_surface([[2,1],[1,1],[2]], [[3,-1],[0,-1],[1]], :ee)\nC-star surface of type (e-e)\n\njulia> special_indices(X)\n2-element Vector{Int64}:\n 0\n 2\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.moment_polytopes-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.moment_polytopes","text":"moment_polytopes(X :: CStarSurface)\n\nReturn the moment polytopes for all k = 0, ..., r, as constructed  in Construction 5.5 of [6].\n\nExample\n\nExample 6.4 from [6].\n\njulia> X = cstar_surface([[2,1],[1,1],[2]], [[3,-1],[0,-1],[1]], :ee)\nC-star surface of type (e-e)\n\njulia> map(vertices, moment_polytopes(X))\n3-element OffsetArray(::Vector{SubObjectIterator{PointVector{QQFieldElem}}}, 0:2) with eltype SubObjectIterator{PointVector{QQFieldElem}} with indices 0:2:\n [[1, 0], [0, -1//2], [-1//2, -1//4], [1//5, 4//5]]\n [[1, 0], [0, 1], [-1//2, 1], [1//5, -2//5]]\n [[1//5, -3//5], [1, 1], [-1//2, 1//4], [0, -1//2]]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Attributes-of-\\mathbb{C}*-surfaces","page":"Surfaces with torus action","title":"Attributes of mathbbC^*-surfaces","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"nblocks\nblock_sizes\nslopes\nhas_x_plus(X :: CStarSurface)\nhas_x_minus(X :: CStarSurface)\nhas_D_plus(X :: CStarSurface)\nhas_D_minus(X :: CStarSurface)\nis_intrinsic_quadric","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.nblocks","page":"Surfaces with torus action","title":"CStarSurfaces.nblocks","text":"nblocks(X :: CStarSurface)\n\nReturns the number of blocks in the generator matrix of a C-star surface.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.block_sizes","page":"Surfaces with torus action","title":"CStarSurfaces.block_sizes","text":"block_sizes(X :: CStarSurface)\n\nReturns the sizes of the blocks in the generator matrix of a C-star surface. The result is a zero-indexed vector of type ZeroVector.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.slopes","page":"Surfaces with torus action","title":"CStarSurfaces.slopes","text":"slopes(X :: CStarSurface)\n\nReturns the DoubleVector of slopes of a C-star surface, i.e a DoubleVector with slopes(X)[i][j] = X.d[i][j] // X.l[i][j].\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_x_plus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_x_plus","text":"has_x_plus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has an elliptic fixed point in the source, commonly denoted x^+.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_x_minus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_x_minus","text":"has_x_minus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has an elliptic fixed point in the sink, commonly denoted x^-.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_D_plus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_D_plus","text":"has_D_plus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has a parabolic fixed point curve in the source, commonly denoted D^+.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_D_minus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_D_minus","text":"has_D_minus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has a parabolic fixed point curve in the sink, commonly denoted D^-.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.is_intrinsic_quadric","page":"Surfaces with torus action","title":"CStarSurfaces.is_intrinsic_quadric","text":"is_intrinsic_quadric(X :: CStarSurface)\n\nChecks whether a C-star surface is an intrinsic quadric, i.e its Cox Ring has a single quadratic relation.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#Normal-forms","page":"Normal forms","title":"Normal forms","text":"","category":"section"},{"location":"admissible_operations.html#Normal-form-of-toric-surfaces","page":"Normal forms","title":"Normal form of toric surfaces","text":"","category":"section"},{"location":"admissible_operations.html","page":"Normal forms","title":"Normal forms","text":"CStarSurfaces.normal_form(X :: ToricSurface)\nCStarSurfaces.is_normal_form(X :: ToricSurface)\nare_isomorphic(X :: ToricSurface, Y :: ToricSurface)","category":"page"},{"location":"admissible_operations.html#CStarSurfaces.normal_form-Tuple{ToricSurface}","page":"Normal forms","title":"CStarSurfaces.normal_form","text":"normal_form(X :: ToricSurface)\n\nBring a toric surface into normal form. Here, we call a toric surface with generator matrix P in normal form, if and only if:\n\nP in Hermite normal form,\nneighbouring columns in P are adjacent rays (i.e. the columns are   sorted either clockwise or counterclockwise),\nP is lexicographically minimal among all generator matrices satisfying 1. and 2.\n\nThese properties are enough to ensure that that two toric surfaces X and Y are isomorphic if and only if gen_matrix(normal_form(X)) == gen_matrix(normal_form(Y)).\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.is_normal_form-Tuple{ToricSurface}","page":"Normal forms","title":"CStarSurfaces.is_normal_form","text":"is_normal_form(X :: ToricSurface)\n\nCheck whether a toric surface is in normal form.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.are_isomorphic-Tuple{ToricSurface, ToricSurface}","page":"Normal forms","title":"CStarSurfaces.are_isomorphic","text":"are_isomorphic(X :: ToricSurface, Y :: ToricSurface)\n\nCheck whether two toric surfaces are isomorphic to each other.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#Types-of-admissible-operations","page":"Normal forms","title":"Types of admissible operations","text":"","category":"section"},{"location":"admissible_operations.html","page":"Normal forms","title":"Normal forms","text":"AdmissibleOperation\nInvertLastRow\nInvertLastRow(factor :: Int)\nPermutationOfRays\nPermutationOfBlocks\nAdmissibleRowOperation\nCompositeAdmissibleOperation\nnormalize_admissible_operation( :: CompositeAdmissibleOperation)","category":"page"},{"location":"admissible_operations.html#CStarSurfaces.AdmissibleOperation","page":"Normal forms","title":"CStarSurfaces.AdmissibleOperation","text":"AdmissibleOperation\n\nAbstract Julia type for admissible operations on C-star surfaces. All subtypes T <: AdmissibleOperation should at least implement the following functions:\n\n( :: T)(X :: CStarSurface)\nBase.:*( :: T,  :: T)\nBase.one( :: T)\nBase.one(::Type{T})\nBase.inv( :: T)\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.InvertLastRow","page":"Normal forms","title":"CStarSurfaces.InvertLastRow","text":"InvertLastRow <: AdmissibleOperation\n\nJulia type for an admissible operation that may or may not invert the last row in the generator matrix of a C-star surface. Geometrically, this means swapping source and sink of the C-star action.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.InvertLastRow-Tuple{Int64}","page":"Normal forms","title":"CStarSurfaces.InvertLastRow","text":"InvertLastRow(factor :: Int)\n\nConstruct an admissible operation that multiplies the last row of the generator matrix of a C-star surface by factor, which can take the values 1 and -1.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.PermutationOfRays","page":"Normal forms","title":"CStarSurfaces.PermutationOfRays","text":"PermutationOfRays <: AdmissibleOperation\n\nJulia type for an admissible operation that permutes rays within the blocks of the generator matrix of C-star surfaces. Only permutations that are local to each block are permitted.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.PermutationOfBlocks","page":"Normal forms","title":"CStarSurfaces.PermutationOfBlocks","text":"PermutationOfBlocks <: AdmissibleOperation\n\nJulia type for an admissible operation that permutes the blocks of the generator matrix of a C-star surface.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.AdmissibleRowOperation","page":"Normal forms","title":"CStarSurfaces.AdmissibleRowOperation","text":"AdmissibleRowOperation <: AdmissibleOperation\n\nJulia type for an admissible operation that adds integral multiples of the  upper rows of the generator matrix of a C-star surface to its last row.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.CompositeAdmissibleOperation","page":"Normal forms","title":"CStarSurfaces.CompositeAdmissibleOperation","text":"CompositeAdmissibleOperation <: AdmissibleOperation\n\nJulia type for an admissible operation that arises as the composition of multiple admissible operations.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.normalize_admissible_operation-Tuple{CompositeAdmissibleOperation}","page":"Normal forms","title":"CStarSurfaces.normalize_admissible_operation","text":"normalize_admissible_operation( :: CompositeAdmissibleOperation)\n\nNormalize a composite admissible operation by reordering the steps and merging multiple operations of the same kind into one. The resulting CompositeAdmissibleOperation is guaranteed to consist of at most four admissible operations in the following order:\n\nInvertLastRow, PermutationOfRays, PermutationOfBlocks, AdmissibleRowOperation.\n\nIf only one type of operation remains, that operation is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#Normal-form-of-\\mathbb{C}*-surfaces","page":"Normal forms","title":"Normal form of mathbbC^*-surfaces","text":"","category":"section"},{"location":"admissible_operations.html","page":"Normal forms","title":"Normal forms","text":"beta_plus\nbeta_minus\nbeta_plus_sorted\nbeta_minus_sorted\norientation\nCStarSurfaces.normal_form(X :: CStarSurface)\nCStarSurfaces.is_normal_form(X :: CStarSurface)\nare_isomorphic(X :: CStarSurface, Y :: CStarSurface)","category":"page"},{"location":"admissible_operations.html#CStarSurfaces.beta_plus","page":"Normal forms","title":"CStarSurfaces.beta_plus","text":"beta_plus(X :: CStarSurface)\n\nReturn a  :: DoubleVector with entries [i][j] == slopes(X)[i][j] - floor(maximum(slopes(X)[i]))\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.beta_minus","page":"Normal forms","title":"CStarSurfaces.beta_minus","text":"beta_minus(X :: CStarSurface)\n\nReturn a  :: DoubleVector with entries [i][j] == ceil(minimum(slopes(X)[i])) - slopes(X)[i][j].\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.beta_plus_sorted","page":"Normal forms","title":"CStarSurfaces.beta_plus_sorted","text":"beta_plus_sorted(X :: CStarSurface)\n\nReturn the sorted beta_plus(X). Each vector in beta_plus(X) are individually sorted and the vectors themselves are sorted by first by size and then lexicographically.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.beta_minus_sorted","page":"Normal forms","title":"CStarSurfaces.beta_minus_sorted","text":"beta_minus_sorted(X :: CStarSurface)\n\nReturn the sorted beta_minus(X). Each vector in beta_minus(X) are individually sorted and the vectors themselves are sorted by first by size and then lexicographically.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.orientation","page":"Normal forms","title":"CStarSurfaces.orientation","text":"orientation(X :: CStarSurface)\n\nReturn the orientation of a C-star surface. This function takes the values 1, 0 or -1. Note that orientation is not an isomorphy invariant, as applying InvertLastRow(-1) inverts the orientation of a C-star surface. All other types of AdmissibleOperation's leave the orientation invariant.\n\nA C-star surface X has orientation 1, if and only if one of the following conditions hold:\n\nX.case == :pe,\nX.case  [:ee, :pp] and m_plus(X) > m_minus(X),\nX.case  [:ee, :pp] and m_plus(X) == m_minus(X) and beta_plus_sorted(X) > beta_minus_sorted(X).\n\nSimilarly, X has orientation -1 if and only if one of the following conditions hold:\n\nX.case == :ep,\nX.case  [:ee, :pp] and m_plus(X) < m_minus(X),\nX.case  [:ee, :pp] and m_plus(X) == m_minus(X) and beta_plus_sorted(X) < beta_minus_sorted(X).\n\nThe remaining case is that X.case  [:ee, :pp] and m_plus(X) == m_minus(X) and beta_plus_sorted(X) == beta_minus_sorted(X), in which case X has orientation 0.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.normal_form-Tuple{CStarSurface}","page":"Normal forms","title":"CStarSurfaces.normal_form","text":"normal_form(X :: CStarSurface)\n\nCompute the normal form of a C-star surface. Here, a C-star surface X is said to be in normal form, if and only if the following properties hold:\n\norientation(X)  -1,\nbeta_plus(X) == beta_plus_sorted(X),\n0  X.d[i][1] < X.l[i][i] for all 1  i  r, where r+1 == nblocks(X).\n\nThe third condition can also be phrased as floor(maximum(slopes(X)[i])) == 0 for all 1  i  r.\n\nThe algorithm works by applying an InvertLastRow operation to achieve 1., then applying PermutationOfRays and PermutationOfBlocks operations to achieve 2. and finally, applying an AdmissibleRowOperation to achieve 3. Together, these properties are enough to ensure that X and Y are isomorphic if and only if they have the same normal form.\n\nThis function then returns a pair (Y, ), where Y is a C-star surface in normal form and  is an admissible operation with (X) == Y.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.is_normal_form-Tuple{CStarSurface}","page":"Normal forms","title":"CStarSurfaces.is_normal_form","text":"is_normal_form(X :: CStarSurface) = normal_form(X)[1] == X\n\nCheck whether a C-star surface is in normal form, see the docstring of normal_form.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.are_isomorphic-Tuple{CStarSurface, CStarSurface}","page":"Normal forms","title":"CStarSurfaces.are_isomorphic","text":"are_isomorphic(X :: CStarSurface, Y :: CStarSurface)\n\nCheck whether two C-star surfaces are isomorphic to each other. This function returns a pair, where the first entry is a boolean and the second entry is either nothing or an admissible operation turning X into Y.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Points","page":"Points","title":"Points","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"We provide an abstract interface for working with points on Mori dream spaces in terms of their Cox coordinates and orbit cone. An implementation for fixed points on mathbbC^*-surfaces (elliptic, hyperbolic and parabolic) as well as toric fixed points on surfaces is provided.","category":"page"},{"location":"points.html#Types","page":"Points","title":"Types","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"MoriDreamSpacePoint\nCStarSurfacePoint\nToricSurfacePoint\nSurfaceWithTorusActionPoint\nCStarSurfaceFixedPoint\nToricSurfaceFixedPoint\nSurfaceWithTorusActionFixedPoint\nEllipticFixedPoint\nEllipticFixedPointPlus\nEllipticFixedPointMinus\nHyperbolicFixedPoint\nParabolicFixedPoint\nParabolicFixedPointPlus\nParabolicFixedPointMinus","category":"page"},{"location":"points.html#CStarSurfaces.MoriDreamSpacePoint","page":"Points","title":"CStarSurfaces.MoriDreamSpacePoint","text":"MoriDreamSpacePoint\n\nA point on a Mori dream space. \n\nSubtypes of MoriDreamSpacePoint should at least implement the following methods: orbit_cone, cox_coordinates, is_quasismooth.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.CStarSurfacePoint","page":"Points","title":"CStarSurfaces.CStarSurfacePoint","text":"CStarSurfacePoint{T <: CStarSurfaceCase} <: MoriDreamSpacePoint\n\nA point on a mathbbC^*-surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.ToricSurfacePoint","page":"Points","title":"CStarSurfaces.ToricSurfacePoint","text":"ToricSurfacePoint <: MoriDreamSpacePoint\n\nA point on a toric surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SurfaceWithTorusActionPoint","page":"Points","title":"CStarSurfaces.SurfaceWithTorusActionPoint","text":"SurfaceWithTorusActionPoint\n\nThe Union of CStarSurfacePoint and ToricSurfacePoint.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.CStarSurfaceFixedPoint","page":"Points","title":"CStarSurfaces.CStarSurfaceFixedPoint","text":"CStarSurfaceFixedPoint{T <: CStarSurfaceCase} <: CStarSurfacePoint{T}\n\nA fixed point on a mathbbC^*-surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.ToricSurfaceFixedPoint","page":"Points","title":"CStarSurfaces.ToricSurfaceFixedPoint","text":"ToricSurfaceFixedPoint <: ToricSurfacePoint\n\nA toric fixed points on a toric surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SurfaceWithTorusActionFixedPoint","page":"Points","title":"CStarSurfaces.SurfaceWithTorusActionFixedPoint","text":"SurfaceWithTorusActionFixedPoint\n\nThe Union of CStarSurfaceFixedPoint and ToricSurfaceFixedPoint.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.EllipticFixedPoint","page":"Points","title":"CStarSurfaces.EllipticFixedPoint","text":"EllipticFixedPoint{T <: CStarSurfaceCase} <: CStarSurfaceFixedPoint{T}\n\nAn elliptic fixed point on a mathbbC^*-surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.EllipticFixedPointPlus","page":"Points","title":"CStarSurfaces.EllipticFixedPointPlus","text":"EllipticFixedPointPlus{T <: Union{EE,EP}} <: EllipticFixedPoint{T}\n\nAn elliptic fixed point x^+ on a mathbbC^*-surface of type (e-e) or (e-p). There should only ever be one instance of this type for any given CStarSurface, which is accessible via x_plus.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.EllipticFixedPointMinus","page":"Points","title":"CStarSurfaces.EllipticFixedPointMinus","text":"EllipticFixedPointMinus{T <: Union{EE,PE}} <: EllipticFixedMinus{T}\n\nAn elliptic fixed point x^- on a mathbbC^*-surface of type (e-e) or (p-e). There should only ever be one instance of this type for any given CStarSurface, which is accessible via x_minus.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.HyperbolicFixedPoint","page":"Points","title":"CStarSurfaces.HyperbolicFixedPoint","text":"HyperbolicFixedPoint{T <: CStarSurfaceCase} <: CStarSurfaceFixedPoint{T}\n\nA hyperbolic fixed point on a mathbbC^*-surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.ParabolicFixedPoint","page":"Points","title":"CStarSurfaces.ParabolicFixedPoint","text":"ParabolicFixedPoint{T <: CStarSurfaceCase} <: CStarSurfaceFixedPoint{T}\n\nA parabolic fixed point on a mathbbC^*-surface.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.ParabolicFixedPointPlus","page":"Points","title":"CStarSurfaces.ParabolicFixedPointPlus","text":"ParabolicFixedPointPlus{T<:Union{PE,PP}} <: ParabolicFixedPoint{T}\n\nA parabolic fixed point x^+_i on a mathbbC^*-surface of type (p-e) or (p-p)\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.ParabolicFixedPointMinus","page":"Points","title":"CStarSurfaces.ParabolicFixedPointMinus","text":"ParabolicFixedPointMinus{T<:Union{EP,PP}} <: ParabolicFixedPoint{T}\n\nA parabolic fixed point x^-_i on a mathbbC^*-surface of type (e-p) or (p-p).\n\n\n\n\n\n","category":"type"},{"location":"points.html#Constructors","page":"Points","title":"Constructors","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"x_plus\nx_minus\nhyperbolic_fixed_point\nparabolic_fixed_point_plus\nparabolic_fixed_point_minus","category":"page"},{"location":"points.html#CStarSurfaces.x_plus","page":"Points","title":"CStarSurfaces.x_plus","text":"x_plus(X :: CStarSurface{<:Union{EE,EP}})\n\nReturn the elliptic fixed point x^+ of a mathbbC^*-surface of type (e-e) or (e-p).\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> x_plus(X)\nelliptic fixed point x^+\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.x_minus","page":"Points","title":"CStarSurfaces.x_minus","text":"x_minus(X :: CStarSurface{<:Union{EE,PE}})\n\nReturn the elliptic fixed point x^- of a mathbbC^*-surface of type (e-e) or (p-e).\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> x_minus(X)\nelliptic fixed point x^-\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.hyperbolic_fixed_point","page":"Points","title":"CStarSurfaces.hyperbolic_fixed_point","text":"hyperbolic_fixed_point(X :: CStarSurface, i :: Int, j :: Int)\n\nReturn the hyperbolic fixed point x_ij of a mathbbC^*-surface, where 0  i  r and 1  j  n_i - 1.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> hyperbolic_fixed_point(X, 0, 1)\nhyperbolic fixed point x(0, 1)\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.parabolic_fixed_point_plus","page":"Points","title":"CStarSurfaces.parabolic_fixed_point_plus","text":"parabolic_fixed_point_plus(X :: CStarSurface{<:Union{PE,PP}}, i :: Int)\n\nReturn the parabolic fixed point x_i^+ of a mathbbC^*-surface, where 0  i  r.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :pe)\nC-star surface of type (p-e)\n\njulia> parabolic_fixed_point_plus(X, 0)\nparabolic fixed point x^+(0)\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.parabolic_fixed_point_minus","page":"Points","title":"CStarSurfaces.parabolic_fixed_point_minus","text":"parabolic_fixed_point_minus(X :: CStarSurface{<:Union{EP,PP}}, i :: Int)\n\nReturn the parabolic fixed point x_i^- of a mathbbC^*-surface, where 0  i  r.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ep)\nC-star surface of type (e-p)\n\njulia> parabolic_fixed_point_minus(X, 0)\nparabolic fixed point x^-(0)\n\n\n\n\n\n","category":"function"},{"location":"points.html#Sets-of-fixed-points","page":"Points","title":"Sets of fixed points","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"elliptic_fixed_points\nhyperbolic_fixed_points\nparabolic_fixed_points_plus\nparabolic_fixed_points_minus\nparabolic_fixed_points\nfixed_points","category":"page"},{"location":"points.html#CStarSurfaces.elliptic_fixed_points","page":"Points","title":"CStarSurfaces.elliptic_fixed_points","text":"elliptic_fixed_points(X :: CStarSurface)\n\nReturn the elliptic fixed points of a mathbbC^*-surface.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> elliptic_fixed_points(X)\n2-element Vector{EllipticFixedPoint{EE}}:\n elliptic fixed point x^+\n elliptic fixed point x^-\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.hyperbolic_fixed_points","page":"Points","title":"CStarSurfaces.hyperbolic_fixed_points","text":"hyperbolic_fixed_points(X :: CStarSurface)\n\nReturn the hyperbolic fixed points of a mathbbC^*-surface as a DoubleVector.\n\nExample\n\njulia> X = cstar_surface([[1,2,1], [1,1], [1,1]], [[3,3,0], [0,-1], [0,-2]], :ee)\nC-star surface of type (e-e)\n\njulia> hyperbolic_fixed_points(X)\n3-element OffsetArray(::Vector{Vector{HyperbolicFixedPoint{EE}}}, 0:2) with eltype Vector{HyperbolicFixedPoint{EE}} with indices 0:2:\n [hyperbolic fixed point x(0, 1), hyperbolic fixed point x(0, 2)]\n [hyperbolic fixed point x(1, 1)]\n [hyperbolic fixed point x(2, 1)]\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.parabolic_fixed_points_plus","page":"Points","title":"CStarSurfaces.parabolic_fixed_points_plus","text":"parabolic_fixed_points_plus(X :: CStarSurface{T}) where {T <: Union{PE,PP}}\n\nReturn the parabolic fixed points x_i^+ of a mathbbC^*-surface.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :pe)\nC-star surface of type (p-e)\n\njulia> parabolic_fixed_points_plus(X)\n3-element OffsetArray(::Vector{ParabolicFixedPointPlus{PE}}, 0:2) with eltype ParabolicFixedPointPlus{PE} with indices 0:2:\n parabolic fixed point x^+(0)\n parabolic fixed point x^+(1)\n parabolic fixed point x^+(2)\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.parabolic_fixed_points_minus","page":"Points","title":"CStarSurfaces.parabolic_fixed_points_minus","text":"parabolic_fixed_points_minus(X :: CStarSurface{T}) where {T <: Union{EP,PP}}\n\nReturn the parabolic fixed points x_i^- of a mathbbC^*-surface.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ep)\nC-star surface of type (e-p)\n\njulia> parabolic_fixed_points_minus(X)\n3-element OffsetArray(::Vector{ParabolicFixedPointMinus{EP}}, 0:2) with eltype ParabolicFixedPointMinus{EP} with indices 0:2:\n parabolic fixed point x^-(0)\n parabolic fixed point x^-(1)\n parabolic fixed point x^-(2)\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.parabolic_fixed_points","page":"Points","title":"CStarSurfaces.parabolic_fixed_points","text":"parabolic_fixed_points(X :: CStarSurface)\n\nReturn the parabolic fixed points of a mathbbC^*-surface.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :pp)\nC-star surface of type (p-p)\n\njulia> parabolic_fixed_points(X)\n6-element Vector{ParabolicFixedPoint{PP}}:\n parabolic fixed point x^+(0)\n parabolic fixed point x^+(1)\n parabolic fixed point x^+(2)\n parabolic fixed point x^-(0)\n parabolic fixed point x^-(1)\n parabolic fixed point x^-(2)\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.fixed_points","page":"Points","title":"CStarSurfaces.fixed_points","text":"fixed_points(X :: CStarSurface)\n\nReturn all fixed points of a mathbbC^*-action. This is the union of elliptic_fixed_points, hyperbolic_fixed_points and parabolic_fixed_points.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ep)\nC-star surface of type (e-p)\n\njulia> fixed_points(X)\n5-element Vector{CStarSurfaceFixedPoint{EP}}:\n elliptic fixed point x^+\n hyperbolic fixed point x(0, 1)\n parabolic fixed point x^-(0)\n parabolic fixed point x^-(1)\n parabolic fixed point x^-(2)\n\n\n\n\n\n","category":"function"},{"location":"points.html#Attributes","page":"Points","title":"Attributes","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"parent(x :: MoriDreamSpacePoint)\norbit_cone\ncox_coordinates\nclass_group(x :: MoriDreamSpacePoint)\nclass_group_rank(x :: MoriDreamSpacePoint)\nclass_group_torsion(x :: MoriDreamSpacePoint)\nclass_group_torsion_order(x :: MoriDreamSpacePoint)\nmap_from_class_group_to_local_class_group(x :: MoriDreamSpacePoint)\ngorenstein_index(x :: MoriDreamSpacePoint)\nis_quasismooth\nis_factorial(x :: MoriDreamSpacePoint)\nis_smooth(x :: MoriDreamSpacePoint)\nis_log_terminal","category":"page"},{"location":"points.html#Base.parent-Tuple{MoriDreamSpacePoint}","page":"Points","title":"Base.parent","text":"parent(x :: MoriDreamSpacePoint)\n\nReturn the Mori dream space where x lives in.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> x = x_plus(X)\nelliptic fixed point x^+\n\njulia> parent(x) === X\ntrue\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.orbit_cone","page":"Points","title":"CStarSurfaces.orbit_cone","text":"orbit_cone(x :: MoriDreamSpacePoint)\n\nGiven a point x in X on a Mori dream space, return the index vector of the cone sigma of the canonical toric ambient variety such that x is contained in the toric orbit associated to sigma.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> orbit_cone(x_plus(X))\n3-element Vector{Int64}:\n 1\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.cox_coordinates","page":"Points","title":"CStarSurfaces.cox_coordinates","text":"cox_coordinates(x :: MoriDreamSpacePoint)\n\nReturn the Cox coordinates of a point on a Mori dream space.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> cox_coordinates(x_plus(X))\n4-element Vector{Int64}:\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"points.html#Hecke.class_group-Tuple{MoriDreamSpacePoint}","page":"Points","title":"Hecke.class_group","text":"class_group(x :: MoriDreamSpacePoint)\n\nReturn the local class group at a given point on a Mori dream space.\n\nExample\n\njulia> X = cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> class_group(x_plus(X))\nGrpAb: Z/2 x Z/18\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.class_group_rank-Tuple{MoriDreamSpacePoint}","page":"Points","title":"CStarSurfaces.class_group_rank","text":"class_group_rank(x :: MoriDreamSpacePoint)\n\nReturn the rank of the local class group at a point on a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.class_group_torsion-Tuple{MoriDreamSpacePoint}","page":"Points","title":"CStarSurfaces.class_group_torsion","text":"class_group_torsion(X :: MoriDreamSpacePoint)\n\nReturn the list of elementary divisors that make up the torsion part of the local class group of a point on a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> class_group_torsion(x_plus(X))\n2-element Vector{ZZRingElem}:\n 2\n 18\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.class_group_torsion_order-Tuple{MoriDreamSpacePoint}","page":"Points","title":"CStarSurfaces.class_group_torsion_order","text":"class_group_torsion_order(X :: MoriDreamSpacePoint)\n\nReturn the order of the torsion part of the class group of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> class_group_torsion_order(x_plus(X))\n36\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.map_from_class_group_to_local_class_group-Tuple{MoriDreamSpacePoint}","page":"Points","title":"CStarSurfaces.map_from_class_group_to_local_class_group","text":"map_from_class_group_to_local_class_group(X :: MoriDreamSpacePoint)\n\nCompute the canonical map from the class group of a Mori dream space to  the local class group at a given point.\n\nExample\n\njulia> X = cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> map_from_class_group_to_local_class_group(x_plus(X))\nMap with following data\nDomain:\n=======\nAbelian group with structure: Z/2 x Z/6 x Z\nCodomain:\n=========\nAbelian group with structure: Z/2 x Z/18\n\n\n\n\n\n","category":"method"},{"location":"points.html#Oscar.gorenstein_index-Tuple{MoriDreamSpacePoint}","page":"Points","title":"Oscar.gorenstein_index","text":"gorenstein_index(X :: MoriDreamSpacePoint)\n\nReturn the local gorenstein index of a point on a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> gorenstein_index(x_plus(X))\n9\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.is_quasismooth","page":"Points","title":"CStarSurfaces.is_quasismooth","text":"is_quasismooth(x :: MoriDreamSpacePoint)\n\nChecks whether a point on a Mori dream space is quasismooth.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_quasismooth(x_plus(X))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.is_factorial-Tuple{MoriDreamSpacePoint}","page":"Points","title":"CStarSurfaces.is_factorial","text":"is_factorial(x :: MoriDreamSpacePoint)\n\nCheck whether a point on a Mori dream space is factorial, i.e. its local class group is trivial.\n\nExample\n\njulia> X = cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_factorial(x_plus(X))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"points.html#Hecke.is_smooth-Tuple{MoriDreamSpacePoint}","page":"Points","title":"Hecke.is_smooth","text":"is_smooth(x :: MoriDreamSpacePoint)\n\nCheck whether a point on a Mori dream space is smooth, i.e. factorial and quasismooth.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_smooth(x_plus(X))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.is_log_terminal","page":"Points","title":"CStarSurfaces.is_log_terminal","text":"is_log_terminal(x :: SurfaceWithTorusActionFixedPoint)\n\nCheck whether a point on a surface with torus action is at most a log terminal singularity.\n\nExample\n\nThe E_6 singular cubic.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_log_terminal(x_plus(X))\ntrue\n\nA non-log terminal singularity.\n\njulia> X = cstar_surface([[5, 7],[3],[2]], [[-1, 2], [1], [-1]], :ee)\nC-star surface of type (e-e)\n\njulia> is_log_terminal(x_plus(X))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"points.html#Resolution-of-singularities","page":"Points","title":"Resolution of singularities","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"canonical_resolution\nminimal_resolution\nlog_canonicity(X :: SurfaceWithTorusActionFixedPoint)\nresolution_graph(X :: SurfaceWithTorusActionFixedPoint)","category":"page"},{"location":"points.html#CStarSurfaces.canonical_resolution","page":"Points","title":"CStarSurfaces.canonical_resolution","text":"canonical_resolution(x :: SurfaceWithTorusActionFixedPoint)\n\nReturn the canonical resolution of singularities of a given fixed point on a surface with torus action. The result is a triple (Y, ex_div, discr) where Y is the resulting surface after the resolution step, ex_div contains the exceptional divisors over x and discrepancies contains their discrepancies.\n\nExample\n\nResolving the elliptic fixed point x^+ of the E_6 singular cubic.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> (Y, ex_div, discr) = canonical_resolution(x_plus(X));\n\njulia> gen_matrix(Y)\n[-3   -1   -2   -1   3   2   1   0   0   0]\n[-3   -1   -2   -1   0   0   0   2   1   0]\n[-2   -1   -1    0   1   1   1   1   1   1]\n\njulia> map(E -> E*E, ex_div)\n6-element Vector{QQFieldElem}:\n -2\n -2\n -2\n -2\n -2\n -2\n\njulia> discr\n6-element Vector{Rational{Int64}}:\n 0//1\n 0//1\n 0//1\n 0//1\n 0//1\n 0//1\n\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.minimal_resolution","page":"Points","title":"CStarSurfaces.minimal_resolution","text":"minimal_resolution(x :: CStarSurfaceFixedPoint)\n\nReturn the minimal resolution of singularities of a mathbbC^*-surface surface X. The minimal resolution is obtained by contracting all (-1)-curves of the canonical resolution. The result is a triple (Y, ex_div, discr) where Y is the resulting mathbbC^*-surface after the resolution step, ex_div contains the exceptional divisors in the resolution and discrepancies contains their discrepancies.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> (Y, ex_div, discr) = minimal_resolution(x_plus(X));\n\njulia> gen_matrix(Y)\n[-3   -1   -2   -1   3   2   1   0   0   0]\n[-3   -1   -2   -1   0   0   0   2   1   0]\n[-2   -1   -1    0   1   1   1   1   1   1]\n\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.log_canonicity-Tuple{SurfaceWithTorusActionFixedPoint}","page":"Points","title":"CStarSurfaces.log_canonicity","text":"log_canonicity(X :: SurfaceWithTorusActionFixedPoint)\n\nReturn the maximal rational number varepsilon such that a given point on a surface with torus action is varepsilon-log canonical. By definition, this is the minimal discrepancy in the resolution of singularities plus one.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> log_canonicity(x_plus(X))\n1//1\n\n\n\n\n\n","category":"method"},{"location":"points.html#CStarSurfaces.resolution_graph-Tuple{SurfaceWithTorusActionFixedPoint}","page":"Points","title":"CStarSurfaces.resolution_graph","text":"resolution_graph(x :: SurfaceWithTorusActionFixedPoint)\n\nReturn the resolution graph of the minimal resolution at a given fixed point of a surface with torus action. The result is a pair with first entry a Graphs.SimpleGraph and second entry the list of self intersection numbers of the exceptional divisors, which serve as node labels of the graph.\n\nExample\n\nThe E_6 singular cubic surface.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> (graph, nodelabel) = resolution_graph(x_plus(X))\n(Graphs.SimpleGraphs.SimpleGraph{Int64}(11, [[1, 2], [1, 2, 6], [3, 4], [3, 4, 6], [5, 6], [2, 4, 5, 6]]), Nemo.QQFieldElem[-2, -2, -2, -2, -2, -2])\n\nThe resolution graph can be visualized with GraphPlot.jl:\n\njulia> using GraphPlot\n\njulia> gplothtml(graph, nodelabel = nodelabel)\n\n\n\n\n\n\n","category":"method"},{"location":"points.html#Singularity-types","page":"Points","title":"Singularity types","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"singularity_type\nSingularityType\nSingularityTypeADE\nSingularityTypeA\nSingularityTypeD\nSingularityTypeE6\nSingularityTypeE7\nSingularityTypeE8\nSingularityTypeNonLogTerminal","category":"page"},{"location":"points.html#CStarSurfaces.singularity_type","page":"Points","title":"CStarSurfaces.singularity_type","text":"singularity_type(x :: SurfaceWithTorusActionFixedPoint)\n\nReturn the singularity type of a fixed point on a surface with torus action.\n\nExamples\n\nThe E_6 singular cubic.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> singularity_type(x_plus(X))\nE6\n\nA non-log terminal singularity.\n\njulia> X = cstar_surface([[5, 7],[3],[2]], [[-1, 2], [1], [-1]], :ee)\nC-star surface of type (e-e)\n\njulia> singularity_type(x_plus(X))\nNon log terminal singularity\n\n\n\n\n\n","category":"function"},{"location":"points.html#CStarSurfaces.SingularityType","page":"Points","title":"CStarSurfaces.SingularityType","text":"SingularityType\n\nAbstract supertype of various \"types\" of singularities.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeADE","page":"Points","title":"CStarSurfaces.SingularityTypeADE","text":"SingularityTypeADE <: SingularityType\n\nAbstract supertype of ADE singularities, i.e. log terminal ones.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeA","page":"Points","title":"CStarSurfaces.SingularityTypeA","text":"SingularityTypeA <: SingularityTypeADE\n\nThe singularity type A_n. It has a single field n that holds the number of nodes in the resolution graph.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeD","page":"Points","title":"CStarSurfaces.SingularityTypeD","text":"SingularityTypeD <: SingularityTypeADE\n\nThe singularity type D_n. It has a single field n that holds the number of nodes in the resolution graph.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeE6","page":"Points","title":"CStarSurfaces.SingularityTypeE6","text":"SingularityTypeE6 <: SingularityTypeADE\n\nThe singularity type E_6.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeE7","page":"Points","title":"CStarSurfaces.SingularityTypeE7","text":"SingularityTypeE7 <: SingularityTypeADE\n\nThe singularity type E_7.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeE8","page":"Points","title":"CStarSurfaces.SingularityTypeE8","text":"SingularityTypeE8 <: SingularityTypeADE\n\nThe singularity type E_8.\n\n\n\n\n\n","category":"type"},{"location":"points.html#CStarSurfaces.SingularityTypeNonLogTerminal","page":"Points","title":"CStarSurfaces.SingularityTypeNonLogTerminal","text":"SingularityTypeNonLogTerminal <: SingularityType\n\nThe singularity type of non log terminal singularities.\n\n\n\n\n\n","category":"type"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = CStarSurfaces","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using CStarSurfaces, Oscar ","category":"page"},{"location":"index.html#CStarSurfaces.jl","page":"Home","title":"CStarSurfaces.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A computer algebra package for rational mathbbC^*-surfaces in the Julia programming language. This package makes use of the OSCAR Computer Algebra System.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The approach to mathbbC^*-surfaces relies on the general combinatorial theory of varieties with finitely generated Cox ring developed in [1], [2] and its specialization to varieties with torus action initiated in [3] and [4]. As an introductory reference, we mention [5].","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The following invariants can be computed for mathbbC^*-surfaces and toric surfaces:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"divisor class group,  local class groups, (anti)canonical divisor class,\nCox Ring,  Gorenstein index,  Picard index,\nintersection numbers,  anticanonical self intersection,\nresolution of singularities,  log canonicity, resolution graphs, ADE singularities,\nnormal form of defining data,  admissible operations,  isomorphy test.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Furthermore, some functionality to save and retrieve mathbbC^*-surfaces from a database is provided, see also the ldp-database.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CStarSurfaces.jl is available in the General Registry, hence can be installed by typing ]add CStarSurfaces into a Julia REPL.","category":"page"},{"location":"index.html#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We work in the notation of [5, Section 5.4].","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Import both Oscar and CStarSurfaces.jl to get started:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Oscar, CStarSurfaces","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"There are essentially two constructors for C-Star surfaces: The first takes the integral vectors l_i=(l_i1 dots l_in_i) and d_i=(d_i1 dots d_in_i) and one of the four symbols :ee, :pe, :ep, :pp. The second takes the generating matrix P of the correct shape:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"X = cstar_surface([[1, 1], [4], [4]], [[0, -2], [3], [3]], :ee)\nY = cstar_surface(ZZ[-1 -1 4 0 ; -1 -1 0 4 ; 0 -2 3 3])\nX == Y","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"gen_matrix returns the generating matrix (P-Matrix) of a C-star surface:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"gen_matrix(X)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"canonical_toric_ambient returns the canonical toric ambient variety of a C-star surface, as an Oscar type:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Z = canonical_toric_ambient(X)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We compute some geometric invariants of X:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"class_group(X)\ncox_ring(X)\ngorenstein_index(X)\npicard_index(X)\nK = anticanonical_divisor(X)\nK * K # the anticanonical self intersection\n(Y, exceptional_divisors, discrepancies) = canonical_resolution(X);\ngen_matrix(Y)\nlog_canonicity(X)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"F.Berchtold and J.Hausen. Cox rings and combinatorics. Trans.Amer.Math.Soc. 359, 12051252 (2007).\n\n\n\nJ.Hausen. Cox rings and combinatorics. II. Mosc.Math.J. 8, 711757, 847 (2008).\n\n\n\nJ.Hausen and E.Herppich. Factorially graded rings of complexity one. In: Torsors, tale homotopy and applications to rational               points, Vol.405 of London Math. Soc. Lecture Note Ser. (Cambridge Univ. Press, Cambridge, 2013); pp.414428.\n\n\n\nJ.Hausen and H.S. The Cox ring of an algebraic variety with torus action. Adv.Math. 225, 9771012 (2010).\n\n\n\nI.Arzhantsev, U.Derenthal, J.Hausen and A.Laface. Cox rings. Vol.144 of Cambridge Studies in Advanced Mathematics (Cambridge University Press, Cambridge, 2015); p.viii+530.\n\n\n\nD.Httig, J.Hausen and H.S. Log del Pezzo ``\\mathbb{C}^``-surfaces, Khler-Einstein metrics, Khler-Ricci solitons and Sasaki-Einstein metrics* (2023), arXiv:2306.03796 [math.AG].\n\n\n\n","category":"page"}]
}
